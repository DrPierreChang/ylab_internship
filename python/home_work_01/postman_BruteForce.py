# список городов
city_names = ["Начало", "Ул. Грибоедова, 104/25",
              "Ул. Бейкер стрит, 221б", "Ул. Большая Садовая, 302-бис",
              "Вечнозелёная Аллея, 742", "Конец"]

# словарь позиций городов
city_locations = {"Начало": (0, 2), "Ул. Грибоедова, 104/25": (2, 5),
                  "Ул. Бейкер стрит, 221б": (5, 2), "Ул. Большая Садовая, 302-бис": (6, 6),
                  "Вечнозелёная Аллея, 742": (8, 3), "Конец": (0, 2)}


# пустой список будет заполняться расчетами расстоний между городами
# как результат будет получен вложенный список/матрица всех расстояний
distances = []
# перебираем города по строкам
for i in city_names:
    # временный список будет обнуляться после добавления расчетов в основной список
    tmp = []
    # перебираем города по столбцам
    for j in city_names:
        # подсчет расстояний по данным точкам
        x1_y1 = city_locations[i]
        x2_y2 = city_locations[j]
        distance = ((x2_y2[0] - x1_y1[0])**2 + (x2_y2[1] - x1_y1[1])**2)**0.5
        tmp.append(distance)
    distances.append(tmp)


# словарь, где будут храниться все просчитанные маршруты
path = dict()

# порядковый номер текущего маршрута
counter = 0

# самый короткий путь — сразу ставим заведомо большим, чтобы уменьшать его по мере работы алгоритма
minPath = 10000

# номер самого короткого маршрута
minCounter = 0

# перебираем все варианты перемещения по городам
for i1 in range(0, 6):
    for i2 in range(0, 6):
        for i3 in range(0, 6):
            for i4 in range(0, 6):
                for i5 in range(0, 6):
                    for i6 in range(0, 6):

                        # нельзя посещать один и тот же город больше одного раза
                        if ((i1 != i2) and (i1 != i3) and (i1 != i4) and (i1 != i5) and (i1 != i6) and
                                (i2 != i3) and (i2 != i4) and (i2 != i5) and (i2 != i6) and
                                (i3 != i4) and (i3 != i5) and (i3 != i6) and
                                (i4 != i5)) and (i4 != i6) and (i5 != i6):
                            # запоминаем текущий путь если
                            # путь начинается и заканчивается на почте:
                            if i1 == 0 and i6 == 5:
                                path[counter] = [i1 + 1, i2 + 1, i3 + 1, i4 + 1, i5 + 1, i6 + 1]

                                # Текущее общее растояние проверяемого пути
                                distance_now = [distances[i1][i2], distances[i2][i3],
                                                distances[i3][i4], distances[i4][i5],
                                                distances[i5][i6]]

                                # если общее расстоения этого пути меньше минимального
                                if sum(distance_now) < minPath:

                                    # то мы запоминаем это минимальное расстояние
                                    minPath = sum(distance_now)

                                    # запоминаем номер этого маршрута с минимальным расстоянием
                                    minCounter = counter

                                    # накопительная сумма текущего минимального пути
                                    sums = []
                                    for i in range(len(distance_now)):
                                        sums.append(sum(distance_now[:i+1]))

                    counter += 1

# Позиции городов финального мнимального пути
positions = [city_locations[city_names[int(x)-1]] for x in path[minCounter]]

# выводим точку старта
print(positions[0], end=" -> ")

# выводим позици у сумму расстояний по мере продвижения
print(*[str(i[0]) + '[' + str(i[1]) + ']' for i in zip(positions[1:], sums)], sep=" -> ", end=" = ")

# выводим конечну сумму
print(sums[-1])
